<!DOCTYPE html>
<html lang="en-gb">
    <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="generator" content="Hugo 0.121.2">

    

    

    
        
            <meta
                name="description"
                content="Adventures in netcode, game engines, and game development" />
        

        
            <meta
                name="keywords"
                content="netcode,programming,gamedev,c&#43;&#43;,unreal,UE5,unity,games,sockets" />
        

        
            <meta
                name="author"
                content="Joe Best-Rotheray" />
        

    


    <title>
        
            Making a Multiplayer FPS in C&#43;&#43; Part 7: The Vulkan Projection Matrix, and Other Graphics Things |
            
        
    </title>

    


    
    

    
    


    
    

    


    
    
        
            
            
        
    

    

    
    

    
    


    

        
        


        
        


        <link
            rel="stylesheet"
            href="/css/index_b09f3b5.min.5169187bcf1ca769555e5986f264b51da52a299e07a76750f8c5490a128848715c1b551dcd4ddbc8d7221324e4ec168fd7ae98456c34a89c1d6c2f83b8086043.css"
            integrity="sha512-UWkYe88cp2lVXlmG8mS1HaUqKZ4Hp2dQ&#43;MVJChKISHFcG1UdzU3byNciEyTk7BaP166YRWw0qJwdbC&#43;DuAhgQw==" />
    


    
    

    

    

    

    

        
            




    
        
    



<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
    integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV"
    crossorigin="anonymous" />


<script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
    crossorigin="anonymous"></script>


<script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
    crossorigin="anonymous"
    onload="renderMathInElement(document.body, { trust: true });"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true },
            ],
            
            throwOnError: false,
            trust: true,
        });
    });
</script>

        

    
</head>



    <body>
        <header class="header">
    <div class="header_left">
        
    </div>

    <div class="header_middle">
        
            Making a Multiplayer FPS in C&#43;&#43; Part 7: The Vulkan Projection Matrix, and Other Graphics Things -
            
        
    </div>
</header>



        <main>
            <aside class="sidebar">
    



    
    

    
    


    <ul class="section-tree">
        
            
                <li
                    
                        class="dir opened-dir"
                    >
                    <span class="dir-text"> Making a Multiplayer FPS in C&#43;&#43; </span>

                    



    
    

    
    


    <ul class="section-tree">
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part8/" title="./multiplayer-fps/part8/">
                         Part 8: Client-Side Prediction Revisited 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part7/" title="./multiplayer-fps/part7/">
                         Part 7: The Vulkan Projection Matrix 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part6/" title="./multiplayer-fps/part6/">
                         Part 6: Cleanup 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part5/" title="./multiplayer-fps/part5/">
                         Part 5: Client-Side Prediction 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part4/" title="./multiplayer-fps/part4/">
                         Part 4: Rebuilding The Client in C&#43;&#43; 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part3/" title="./multiplayer-fps/part3/">
                         Part 3: Multiple Players 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part2/" title="./multiplayer-fps/part2/">
                         Part 2: The Main Loop 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/multiplayer-fps/part1/" title="./multiplayer-fps/part1/">
                         Part 1: Hello Multiplayer World 
                    </a>
                </li>
            
        
    </ul>


                </li>
            
        
            
                <li
                    
                        class="dir closed-dir"
                    >
                    <span class="dir-text"> Posts </span>

                    



    
    

    
    


    <ul class="section-tree">
        
            
                <li class="file">
                    <a href="https://codersblock.org/posts/unity-client-side-prediction/" title="./posts/unity-client-side-prediction/">
                         Client-Side Prediction With Physics In Unity 
                    </a>
                </li>
            
        
            
                <li class="file">
                    <a href="https://codersblock.org/posts/ditching-the-mutex/" title="./posts/ditching-the-mutex/">
                         Ditching the Mutex 
                    </a>
                </li>
            
        
    </ul>


                </li>
            
        
    </ul>


</aside>
<aside class="exapandable"></aside>


            
    <article class="main">
        <button
    class="sidebar-toggle-btn"
    type="menu"
    aria-expanded="false"
    aria-haspopup="true">
    <i class="bi bi-list"></i>
</button>


        
            <div class="headerLogo">
                <a href="https://codersblock.org/"><img src="https://codersblock.org/images/logo.png"/></a>
            </div>
        
        <div class="title">
            <h1 class="title-header">
                Making a Multiplayer FPS in C&#43;&#43; Part 7: The Vulkan Projection Matrix, and Other Graphics Things
            </h1>

            <div class="author-date-readtime">
                

                    
                        <div class="author" title="Author">
                            <i class="bi bi-person"></i>
                            <a
                                href="/author/joe-best-rotheray/"
                                class="cat-btn">
                                Joe Best-Rotheray
                            </a>
                        </div>
                    

                

                
                    <div class="date" title="Date">
                        <i class="bi bi-calendar3"></i>
                        <time
                            datetime="2019.05.29"
                            >2019.05.29
                        </time>
                    </div>
                

                
                    <div
                        class="readtime"
                        title="Time to Read">
                        <i class="bi bi-clock"></i>
                        20 mins to read
                    </div>
                
            </div>
        </div>

        <div class="article-meta">
            

            

            
                <div class="breadcumb">
                    <i class="bi bi-folder"></i>
                    
    
    




<a href="https://codersblock.org/" class="bread-btn">
    
        <i class="bi bi-house-fill"></i>
    

    
        Home
    
</a>




    /



<a href="https://codersblock.org/multiplayer-fps/" class="bread-btn">
    

    
        Making a Multiplayer FPS in C&#43;&#43;
    
</a>




    /



<a href="https://codersblock.org/multiplayer-fps/part7/" class="bread-btn">
    

    
        Part 7: The Vulkan Projection Matrix
    
</a>

                </div>
            

            
        </div>

        
            

        


        <div class="content">
            
                <p>In the previous part of the series I mostly did some miscellaneous cleanup. This part unfortunately has no netcode whatsoever - it’s all about graphics (<a href="https://github.com/spectre1989/odin/tree/87247f5f0fd5acd86873e3f3bc8524fcafeced46">browse code here, it’s not pretty</a>).</p>
<h3 id="youre-not-a-graphics-programmer-stupid">&ldquo;You’re Not A Graphics Programmer, Stupid&rdquo;</h3>
<p>I’m no graphics guy, but I’m hoping I can still make an acceptable renderer. I’m trying to take a from-scratch approach with this thing, and graphics will be no exception. This means I need to derive the most basic building blocks like projection and transformation matrices, armed only with my B grade in A-Level maths from more than a decade ago. Though you don’t ever really <em>need</em> to do this sort of thing these days, it’s still (in my view) an interesting and worthwhile exercise.</p>
<h3 id="the-coordinate-system">The Coordinate System</h3>
<p>Firstly I need to pick a coordinate system. For some reason, I always liked positive X-axis right, positive Y-axis up, and positive Z-axis forwards. I really have no idea why, but I found this tweet which nicely sums up the different coordinate systems and which engines/programs use which:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Here, have a coordinate system chart! <a href="http://t.co/riYtt6tLEd">pic.twitter.com/riYtt6tLEd</a></p>&mdash; Freya the stray (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/644881436982575104?ref_src=twsrc%5Etfw">September 18, 2015</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>It seems that I&rsquo;m weird in thinking that Y is up (maybe it&rsquo;s because in graphics, Y is up/down the screen). It also seems that Unreal are on their own with left-handed Z-up, right-handed Z-up has Cryengine(and Lumberyard?), Source Engine, and more importantly Max and Blender. Seeing as I&rsquo;m a sheep, I&rsquo;ll just follow those guys - right-handed Z-up. That means positive X-axis right, positive Y-axis forward, and positive Z-axis up.</p>
<h3 id="calculating-the-projection-matrix">Calculating the Projection Matrix</h3>
<p>To render in 3D at all, we need to project from 3D points in space, to 2D points on the screen. This projection process ultimately ends with <em><strong>Normalised Device Coordinates</strong></em> (NDC), with Vulkan the top-left corner of the window is (-1, -1) in X and Y, and the bottom-right corner of the window is (1, 1). Regardless of the aspect ratio of the screen, it&rsquo;s always in that range from edge to edge. The Z component is depth, and that should be in the range of 0 to 1, from closest to furthest respectively.</p>



    



    

<img src="/images/mpfps_07/diag01_hu84139e78df89a5eaed29b97f10b88ccb_44859_1000x0_resize_box_3.png"/>
<p>The graphics API doesn&rsquo;t actually want NDC coordinates to do its drawing business though, it wants <em><strong>Clip Coordinates</strong></em>, which are converted to NDC coordinates by dividing by the W component (this is the <em><strong>Perspective Division</strong></em>).</p>
<p>$$ NDC = {{(Clip_X, \text{ } Clip_Y, \text{ } Clip_Z)} \over Clip_W} $$</p>
<p>So you could also say that:</p>
<p>$$ Clip = (NDC_X * Clip_W, \text{ } NDC_Y * Clip_W, \text{ } NDC_Z * Clip_W, \text{ } Clip_W) $$</p>
<p>In summary, the projection matrix needs to carry out the following transformation:</p>
<p>$$(World_X, \text{ } World_Y, \text{ } World_Z) \rightarrow (NDC_X * Clip_W, \text{ } NDC_Y * Clip_W, \text{ } NDC_Z * Clip_W, \text{ } Clip_W) $$</p>
<p>So, a &ldquo;camera&rdquo; has a few key properties:</p>
<ul>
<li>field of view (FOV) - this can be either horizontal or vertical</li>
<li>aspect ratio - width/height of the screen, this can be used to calculate the field of view in the other direction</li>
<li>near clipping plane - the distance away from the camera origin that the screen sits, in world-space</li>
<li>far clipping plane - points further from the camera origin than this will not be drawn</li>
</ul>
<p>These properties define the camera frustum, 3D points outside of this volume will be ignored:</p>



    



    

<img src="/images/mpfps_07/diag02_hufa93b1fd2ad7407967c3a3c60155e6cb_134215_1000x0_resize_box_3.png"/>
<p>Note: I like camera FOV to be vertical, and then calculate the horizontal. Let&rsquo;s say someone has a really wide monitor, if FOV is fixed horizontally, then effectively for them the vertical FOV is reduced like they&rsquo;re looking through a letterbox. I prefer to have a fixed sensible vertical FOV, and then let horizontal FOV scale based on the aspect ratio of the screen.</p>
<p>Imagine we&rsquo;re projecting the z component of the point:</p>



    



    

<img src="/images/mpfps_07/diag03_hu87790d7e9f8d2d12799c40d422942085_69041_1000x0_resize_box_3.png"/>
<p>It will be projected along this line towards the camera.</p>



    



    

<img src="/images/mpfps_07/diag04_hu40dbcc37fd15e095470c95969df7f194_82180_1000x0_resize_box_3.png"/>
<p>Passing through the near plane, this is where the projected point will be on the screen.</p>



    



    

<img src="/images/mpfps_07/diag05_hu40dbcc37fd15e095470c95969df7f194_82394_1000x0_resize_box_3.png"/>
<p>Finding the position on the near plane is a case of solving two triangles. The first triangle is from the camera to the point:</p>



    



    

<img src="/images/mpfps_07/diag06_huc2c68305a481a0f9d722aa448abe93b2_93449_1000x0_resize_box_3.png"/>
<p>Trig 101 - the 3 sides of a right-angled triangle are referred to as opposite (the side opposite angle θ), adjacent (the other side which forms the right-angle of the triangle), and hypotenuse (the longest side, opposite the right-angle).</p>



    



    

<img src="/images/mpfps_07/diag07_huc2c68305a481a0f9d722aa448abe93b2_106159_1000x0_resize_box_3.png"/>
<p>The Z coordinate is the opposite side, and the Y coordinate is the adjacent side.</p>



    



    

<img src="/images/mpfps_07/diag08_huc2c68305a481a0f9d722aa448abe93b2_113223_1000x0_resize_box_3.png"/>
<p>So <em><strong>θ</strong></em> can be calculated (using <a href="https://www.mathwords.com/s/sohcahtoa.htm">SOHCAHTOA</a>) like this:</p>
<p>$$ \tan(\theta) = {opp \over adj} $$
$$ \theta = \arctan({opp \over adj}) $$
$$ \theta = \arctan({World_Z \over World_Y}) $$</p>
<p>The second triangle is from the camera to the projected point:</p>
<p>


    



    

<img src="/images/mpfps_07/diag09_hue1a12ef0bbbdea4cb5e71270a6ddbd18_62552_1000x0_resize_box_3.png"/>



    



    

<img src="/images/mpfps_07/diag10_hu983dd1c202adf5b3b3e056744c9f2c29_84433_1000x0_resize_box_3.png"/></p>
<p><em><strong>θ</strong></em> will be the same as in the first triangle, the near plane distance is the adjacent side, and the opposite side is the projected <em><strong>Z</strong></em> coordinate of the point on the near plane. Armed with <em><strong>θ</strong></em> and the near plane distance, the projected <em><strong>Z</strong></em> is calculated like this:</p>
<p>$$ \tan(\theta) = {opp \over adj} $$
$$ \tan(\theta) * adj = opp $$
$$ \tan(\theta) * \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance} = Proj_Z $$</p>
<p>This gives the projected coordinate in world-space, but remember we need NDC coordinates in the range of -1 to +1. The near plane in world space ranges from (-width/2, height/2) to (width/2, -height/2), so we need to map these world space positions to the NDC coordinates (-1, -1) and (1, 1) respectively.</p>



    



    

<img src="/images/mpfps_07/diag11_hu923ebff897607ab8bfcef72d0c29ef31_81556_1000x0_resize_box_3.png"/>
<p>In order to calculate this we need to know the height of the near plane in world-space. How do we find that out? More triangles!</p>



    



    

<img src="/images/mpfps_07/diag12_hucd76a6999392e9c81c5fa3ac1963e3db_98282_1000x0_resize_box_3.png"/>
<p>This triangle is made up of a half of the camera field-of-view, so the opposite side of the triangle will be half the size of the near plane in world-space. Calculate just like projecting the point earlier:</p>
<p>$$ \tan(\theta) = {opp \over adj} $$
$$ \tan(\theta) * adj = opp $$
$$ \tan({fov \over 2}) * \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance} = {\text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{height} \over 2} $$</p>
<p>The near plane will span world Z coordinates from -height/2 to +height/2, and these will map to +1 to -1 in NDC (remember +ve Y NDC coordinates go down the screen, whereas +ve Z world coordinates go up the screen). So to convert from a world-space projected Z value to NDC Y, just divide by negative half the size:</p>
<p>$$ NDC_Y = {Proj_Z \over -({\text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{height} \over 2})} $$</p>
<p>Putting the whole thing together:</p>
<p>$$ NDC_Y = {Proj_Z \over -({\text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{height} \over 2})} $$</p>
<p>$$ NDC_Y = {\tan(\theta) * \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance} \over -({\text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{height} \over 2})} $$</p>
<p>$$ NDC_Y = {\tan(\arctan({World_Z \over World_Y})) * \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance} \over -({\text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{height} \over 2})} $$</p>
<p>$$ NDC_Y = {(\tan(\arctan({World_Z \over World_Y})) * \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance}) \over -(\tan({fov \over 2} ) * \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance}) } $$</p>
<p>$$ NDC_Y = {\htmlStyle{text-decoration: line-through;}{(\tan(\arctan(}{World_Z \over World_Y})) \htmlStyle{text-decoration: line-through;}{* \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance}}) \over -(\tan({fov \over 2} ) \htmlStyle{text-decoration: line-through;}{* \text{near}\text{\textunderscore}\text{plane}\text{\textunderscore}\text{distance}}) } $$</p>
<p>$$ NDC_Y = {{World_Z \over World_Y} \over -\tan({fov \over 2} ) } $$</p>
<p>There’s a problem with this - the part where <strong>Z</strong> is divided by <strong>Y</strong>, matrix multiplication doesn’t allow us to divide one component of the input by another component. This isn’t an actual problem though, remember the value we&rsquo;re actually trying to get out from the matrix multiplication is the clip coordinates, the magical graphics fairies will divide the clip coordinates with the <strong>W</strong> component of the clip coordinates. So we can just use the world <strong>Y</strong> value:</p>
<p>$$ Clip_W = World_Y $$ $$ Clip_Y = NDC_Y * Clip_W $$ $$ Clip_Y = NDC_Y * World_Y $$ $$ Clip_Y = {{World_Z \over World_Y} \over -\tan({fov \over 2} ) } * World_Y $$ $$ Clip_Y = {{World_Z \over \htmlStyle{text-decoration: line-through;}{World_Y}} \over -\tan({fov \over 2} ) } \htmlStyle{text-decoration: line-through;}{* World_Y} $$ $$ Clip_Y = {World_Z \over -\tan({fov \over 2} ) } $$</p>
<p>Next to work on the X component, the formula is the same as before, except we divide by +tan(fov/2), because NDC coordinates in the X-axis go positive from left to right, just like the world coordinates:</p>
<p>$$ Clip_X = {World_X \over \tan({fov \over 2})} $$</p>
<p>But the X component will be using a different FOV (horizontal, rather than vertical). As I said earlier, we calculate this from the vertical FOV and the camera aspect ratio. Remember though, we use the FOV to calculate the world-space size of the near plane, so we don&rsquo;t actually need to know the horizontal FOV, just the horizontal size of the near plane. The aspect ratio of the near plane will be the same as the aspect ratio of the camera, so we can find the horizontal size of the near plane by multiplying the vertical size by aspect ratio:</p>
<p>$$ Clip_X = {World_X \over \tan({fov \over 2}) * \text{aspect}\text{\textunderscore}\text{ratio}} $$</p>
<p>Unlike X and Y, Z (depth) should range from 0 to 1, with 0 being close to the camera, and 1 being far away. Therefore 0 will map to the near plane, and 1 will map to the far plane. That could be done with a simple linear relationship, but it&rsquo;s better to actually give more space in the depth buffer to objects which are closer to the camera. This is because you&rsquo;re more likely to notice depth related artifacts like <a href="https://www.google.com/search?tbm=isch&amp;source=hp&amp;biw=1080&amp;bih=1783&amp;ei=25JpW8maOI6OlwTt06bgBw&amp;q=z-fighting&amp;oq=z-fighting&amp;gs_l=img.3..35i39k1j0i30k1l7j0i24k1l2.2859.4072.0.4172.12.12.0.0.0.0.83.527.10.10.0....0...1ac.1.64.img..2.10.526.0..0j0i10i30k1.0.pEk9pmSEzDs">Z-fighting</a> on things which are in the foreground rather than the background. A good formula to base this off is:</p>
<p>$$ NDC_Z = {m \over World_Y} + c $$</p>



    



    

<img src="/images/mpfps_07/diag13_hu08bb3f19c16d3f562bec46a278a4207a_89646_1000x0_resize_box_3.png"/>
<p>We also know that this formula will be equal to 0 when the Y value is equal to the near plane:</p>
<p>$$ NDC_Z = {m \over World_Y} + c $$
$$ 0 = {m \over near} + c $$
$$ c = -{m \over near} $$</p>
<p>And a Y value equal to the far plane will produce a value of 1:</p>
<p>$$ 1 = {m \over far} + c $$
$$ c = 1 - {m \over far} $$</p>
<p>These two simultaneous equations allow to solve for m:</p>
<p>$$ c = -{m \over near} $$
$$ c = 1 - {m \over far} $$
$$ -{m \over near} = 1 - {m \over far} $$
$$ -m = near - {m * near \over far} $$
$$ -m * far = (near * far) - (m * near) $$
$$ (m * near) - (m * far) = near * far $$
$$ m * (near - far) = near * far $$
$$ m = {near * far \over near - far} $$</p>
<p>Use the value of m to solve for c:</p>
<p>$$ 0 = {m \over near} + c $$
$$ 0 = {{near * far \over near - far} \over near} + c $$
$$ 0 = {far \over near - far} + c $$
$$ c = {-far \over near - far} $$
$$ c = {far \over far - near} $$</p>
<p>Putting it all together:</p>
<p>$$ NDC_Z = {{near * far \over near - far} \over World_Y} + {far \over far - near} $$</p>
<p>However, again the value that is output from the matrix will have this division by the world Y component done automatically, so just multiply that formula by Y to get the desired output:</p>
<p>$$ Clip_Z = {near * far \over near-far} + {World_Y * far \over far-near} $$</p>
<p>Now to combine all of these into a 4x4 projection matrix. Matrices are multiplied along the rows of the projection matrix, and down the column of the vector being transformed (more on matrix multiplication <a href="https://www.mathsisfun.com/algebra/matrix-multiplying.html">here</a> if needed).</p>
<p>$$ \begin{bmatrix}
Out_X \\
Out_Y \\
Out_Z \\
Out_W
\end{bmatrix} =
\begin{bmatrix}
\color{IndianRed}{M_{11}} &amp; \color{PaleGreen}{M_{12}} &amp; \color{LightSkyBlue}{M_{13}} &amp; \color{Khaki}{M_{14}} \\
\color{IndianRed}{M_{21}} &amp; \color{PaleGreen}{M_{22}} &amp; \color{LightSkyBlue}{M_{23}} &amp; \color{Khaki}{M_{24}} \\
\color{IndianRed}{M_{31}} &amp; \color{PaleGreen}{M_{32}} &amp; \color{LightSkyBlue}{M_{33}} &amp; \color{Khaki}{M_{34}} \\
\color{IndianRed}{M_{41}} &amp; \color{PaleGreen}{M_{42}} &amp; \color{LightSkyBlue}{M_{43}} &amp; \color{Khaki}{M_{44}}
\end{bmatrix}
\begin{bmatrix}
\color{IndianRed}{In_X} \\
\color{PaleGreen}{In_Y} \\
\color{LightSkyBlue}{In_Z} \\
\color{Khaki}{In_W}
\end{bmatrix} $$</p>
<p>So if we start with the first row of the matrix, which will produce the output X value:</p>
<p>$$ Out_X = (\color{IndianRed}{M_{11} * In_X}) + (\color{PaleGreen}{M_{12} * In_Y}) + (\color{LightSkyBlue}{M_{13} * In_Z}) + (\color{Khaki}{M_{14} * In_W}) $$</p>
<p>The desired output value is:</p>
<p>$$ \color{IndianRed}{In_X} \over {\tan({fov \over 2}) * \text{aspect}\text{\textunderscore}\text{ratio}} $$</p>
<p>The only input component needed is X, so that will just be the M11 value, making the first row of the matrix:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{1 \over \tan({fov \over 2}) * \text{aspect}\text{\textunderscore}\text{ratio}} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0}
\end{bmatrix}$$</p>
<p>Then for the second row:</p>
<p>$$ Out_Y = (\color{IndianRed}{M_{21} * In_X}) + (\color{PaleGreen}{M_{22} * In_Y}) + (\color{LightSkyBlue}{M_{23} * In_Z}) + (\color{Khaki}{M_{24} * In_W}) $$</p>
<p>The desired output of which is:</p>
<p>$$ \color{LightSkyBlue}{In_Z} \over {-\tan({fov \over 2})} $$</p>
<p>Which will be M23 value, making the second row:</p>
<p>$$ \begin{bmatrix}
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{-1 \over \tan({fov \over 2})} &amp; \color{Khaki}{0}
\end{bmatrix} $$</p>
<p>The third row will output the Z (depth) value:</p>
<p>$$ Out_Z = (\color{IndianRed}{M_{31} * In_X}) + (\color{PaleGreen}{M_{32} * In_Y}) + (\color{LightSkyBlue}{M_{33} * In_Z}) + (\color{Khaki}{M_{34} * In_W}) $$</p>
<p>Which needs to output:</p>
<p>$$ \color{Khaki}{near * far \over near - far} + \color{PaleGreen}{In_Y * far \over far - near} $$</p>
<p>This makes use of two components, the Y component is the obvious one (M32), and a constant. For the constant the W component (M34) is used (the input vertex will have 1 for the W component):</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{0} &amp; \color{PaleGreen}{far \over far - near} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{near * far \over near - far}
\end{bmatrix}$$</p>
<p>The final row will output the W value used to divide the X/Y/Z values to output NDC coordinates, and will be the distance from the camera to the point. So all that&rsquo;s needed is the Y component, which means the final row will be:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0}
\end{bmatrix}$$</p>
<p>All of those rows together:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{1 \over \tan({fov \over 2}) * \text{aspect}\text{\textunderscore}\text{ratio}} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{-1 \over \tan({fov \over 2})} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{far \over far - near} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{near * far \over near - far} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0}
\end{bmatrix}$$</p>
<h3 id="calculating-the-model-matrix">Calculating The Model Matrix</h3>
<p>The next matrix that&rsquo;ll be needed is a model matrix - again you can just look this up, but figuring it out from first principles is quite simple. To recap, transforming a vector with a matrix:</p>
<p>$$ Out_X = (\color{IndianRed}{M_{11} * In_X}) + (\color{PaleGreen}{M_{12} * In_Y}) + (\color{LightSkyBlue}{M_{13} * In_Z}) + (\color{Khaki}{M_{14} * In_W}) $$
$$ Out_Y = (\color{IndianRed}{M_{21} * In_X}) + (\color{PaleGreen}{M_{22} * In_Y}) + (\color{LightSkyBlue}{M_{23} * In_Z}) + (\color{Khaki}{M_{24} * In_W}) $$
$$ Out_Z = (\color{IndianRed}{M_{31} * In_X}) + (\color{PaleGreen}{M_{32} * In_Y}) + (\color{LightSkyBlue}{M_{33} * In_Z}) + (\color{Khaki}{M_{34} * In_W}) $$
$$ Out_W = (\color{IndianRed}{M_{41} * In_X}) + (\color{PaleGreen}{M_{42} * In_Y}) + (\color{LightSkyBlue}{M_{43} * In_Z}) + (\color{Khaki}{M_{44} * In_W}) $$</p>
<p>When transforming a vector which is just a direction (e.g. a surface normal), the W component will always be 0, so we can simplify the above to:</p>
<p>$$ Out_X = (\color{IndianRed}{M_{11} * In_X}) + (\color{PaleGreen}{M_{12} * In_Y}) + (\color{LightSkyBlue}{M_{13} * In_Z}) $$
$$ Out_Y = (\color{IndianRed}{M_{21} * In_X}) + (\color{PaleGreen}{M_{22} * In_Y}) + (\color{LightSkyBlue}{M_{23} * In_Z}) $$
$$ Out_Z = (\color{IndianRed}{M_{31} * In_X}) + (\color{PaleGreen}{M_{32} * In_Y}) + (\color{LightSkyBlue}{M_{33} * In_Z}) $$
$$ Out_W = (\color{IndianRed}{M_{41} * In_X}) + (\color{PaleGreen}{M_{42} * In_Y}) + (\color{LightSkyBlue}{M_{43} * In_Z}) $$</p>
<p>Whereas if the vector is a point in space, then W will always be 1:</p>
<p>$$ Out_X = (\color{IndianRed}{M_{11} * In_X}) + (\color{PaleGreen}{M_{12} * In_Y}) + (\color{LightSkyBlue}{M_{13} * In_Z}) + \color{Khaki}{M_{14}} $$
$$ Out_Y = (\color{IndianRed}{M_{21} * In_X}) + (\color{PaleGreen}{M_{22} * In_Y}) + (\color{LightSkyBlue}{M_{23} * In_Z}) + \color{Khaki}{M_{24}} $$
$$ Out_Z = (\color{IndianRed}{M_{31} * In_X}) + (\color{PaleGreen}{M_{32} * In_Y}) + (\color{LightSkyBlue}{M_{33} * In_Z}) + \color{Khaki}{M_{34}} $$
$$ Out_W = (\color{IndianRed}{M_{41} * In_X}) + (\color{PaleGreen}{M_{42} * In_Y}) + (\color{LightSkyBlue}{M_{43} * In_Z}) + \color{Khaki}{M_{44}} $$</p>
<p>Translation is the simplest part, this is just an addition. We can see above that M14 will be added to X, M24 to Y, and M34 to Z. So the translation vector can be stored in those three components of the matrix. We&rsquo;ll want to maintain the existing X/Y/Z/W components too, just like the identity matrix, so M11/M22/M33/M44 will all be 1.</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{1} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{Translation_X} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{Translation_Y} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{1} &amp; \color{Khaki}{Translation_Z} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>Next is rotation. The convention is that a rotation of θ radians around an axis, is counter-clockwise around that axis, if that axis is pointing towards the observer:</p>



    



    

<img src="/images/mpfps_07/diag14_huc5d6c0e7fec0d07833b7f52c501f6adc_43035_1000x0_resize_box_3.png"/>
<p>Rotating a point around the origin is just a case of using a combination of sin(<em><strong>θ</strong></em>) and cos(<em><strong>θ</strong></em>) to move the point in an arc. I don&rsquo;t find this stuff intuitive, so I just brute-forced a solution.</p>
<p>So let&rsquo;s start with a rotation around the X-axis. Take for example, the point (Y=0, Z=2), we don&rsquo;t care about X here because we&rsquo;re rotating around the X-axis:</p>



    



    

<img src="/images/mpfps_07/diag15_hu4366dc43663846d9e6507f03b237a5a8_85616_1000x0_resize_box_3.png"/>
<p>We can see that a rotation of 90° produces (Y=-2, Z=0). We also know that cos(90°)=0, and sin(90°)=1. Therefore in this case, we could say:</p>
<p>$$ Out_Y = \color{LightSkyBlue}{-\sin(\theta) * In_Z} $$</p>
<p>Looking at a rotation of 180°, we get (Y=0, Z=-2). Cos(180°)=-1, sin(180°)=0, so:</p>
<p>$$ Out_Z = \color{LightSkyBlue}{\cos(\theta) * In_Z} $$</p>
<p>Now do the same process with the point (Y=2, Z=0):</p>



    



    

<img src="/images/mpfps_07/diag16_hu36294fa869d6ba3bd75c8dca3e35a449_85383_1000x0_resize_box_3.png"/>
<p>A rotation of 90° results in (Y=0, Z=2), cos(90°)=0, and sin(90°)=1, so:</p>
<p>$$ Out_Z = \color{PaleGreen}{\sin(\theta) * In_Y} $$</p>
<p>A rotation of 180° results in (Y=-2, Z=0), cos(180°)=-1, sin(180°)=0, so:</p>
<p>$$ Out_Y = \color{PaleGreen}{\cos(\theta) * In_Y} $$</p>
<p>Putting it all together:</p>
<p>$$ Out_Y = (\color{PaleGreen}{\cos(\theta) * In_Y}) - (\color{LightSkyBlue}{\sin(\theta) * In_Z}) $$
$$ Out_Z = (\color{PaleGreen}{\sin(\theta) * In_Y}) + (\color{LightSkyBlue}{\cos(\theta) * In_Z}) $$</p>
<p>Going all the way back to the output of the matrix:</p>
<p>$$ Out_Y = (\color{IndianRed}{M_{21} * In_X}) + (\color{PaleGreen}{M_{22} * In_Y}) + (\color{LightSkyBlue}{M_{23} * In_Z}) + \color{Khaki}{M_{24}} $$
$$ Out_Z = (\color{IndianRed}{M_{31} * In_X}) + (\color{PaleGreen}{M_{32} * In_Y}) + (\color{LightSkyBlue}{M_{33} * In_Z}) + \color{Khaki}{M_{34}} $$</p>
<p>So we can see that:</p>
<p>$$ \color{PaleGreen}{M_{22}} = \cos(\theta) $$
$$ \color{LightSkyBlue}{M_{23}} = -\sin(\theta) $$
$$ \color{PaleGreen}{M_{32}} = \sin(\theta) $$
$$ \color{LightSkyBlue}{M_{33}} = \cos(\theta) $$</p>
<p>So the matrix to rotate around the X-axis should look like this:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{1} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{\cos(\theta)} &amp; \color{LightSkyBlue}{-\sin(\theta)} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{\sin(\theta)} &amp; \color{LightSkyBlue}{\cos(\theta)} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>Repeat the process for rotations around Y and Z - I won’t bore you with the working for those, but the matrix to rotate around the Y-axis looks like this:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{\cos(\theta)} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{\sin(\theta)} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0} \\
\color{IndianRed}{-\sin(\theta)} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{\cos(\theta)} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>The matrix to rotate around the Z-axis looks like this:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{\cos(\theta)} &amp; \color{PaleGreen}{-\sin(\theta)} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0} \\
\color{IndianRed}{\sin(\theta)} &amp; \color{PaleGreen}{\cos(\theta)} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{1} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>Another way to construct a model matrix is from the internal Right/Forward/Up axes of the object.</p>



    



    

<img src="/images/mpfps_07/diag17_hu1614f43293e64f189cc0fc6b0ad4a853_43635_1000x0_resize_box_3.png"/>
<p>$$\begin{bmatrix}
\color{IndianRed}{Right_X} &amp; \color{PaleGreen}{Forward_X} &amp; \color{LightSkyBlue}{Up_X} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Right_Y} &amp; \color{PaleGreen}{Forward_Y} &amp; \color{LightSkyBlue}{Up_Y} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Right_Z} &amp; \color{PaleGreen}{Forward_Z} &amp; \color{LightSkyBlue}{Up_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>This makes intuitive sense when you picture what’s happening, what this matrix does is:</p>
<p>$$ Out = (\color{IndianRed}{Right * In_X}) + (\color{PaleGreen}{Forward * In_Y}) + (\color{LightSkyBlue}{Up * In_Z}) $$</p>
<p>So the X component of any vector gets multiplied by the model right vector, the Y by forward, and the Z by up. So it just takes the magnitude of the input vector along the basis X/Y/Z axes, and then uses those as a scale applied to the model right/forward/up axes.</p>
<p>Combining a rotation matrix with translation is simple (you want to do rotation and then translation with a model transform):</p>
<p>$$ \begin{bmatrix}
\color{IndianRed}{1} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{Translation_X} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{Translation_Y} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{1} &amp; \color{Khaki}{Translation_Z} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}
\begin{bmatrix}
\color{IndianRed}{Right_X} &amp; \color{PaleGreen}{Forward_X} &amp; \color{LightSkyBlue}{Up_X} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Right_Y} &amp; \color{PaleGreen}{Forward_Y} &amp; \color{LightSkyBlue}{Up_Y} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Right_Z} &amp; \color{PaleGreen}{Forward_Z} &amp; \color{LightSkyBlue}{Up_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix} $$</p>
<p>If you multiply this out you get:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{Right_X} &amp; \color{PaleGreen}{Forward_X} &amp; \color{LightSkyBlue}{Up_X} &amp; \color{Khaki}{Translation_X} \\
\color{IndianRed}{Right_Y} &amp; \color{PaleGreen}{Forward_Y} &amp; \color{LightSkyBlue}{Up_Y} &amp; \color{Khaki}{Translation_Y} \\
\color{IndianRed}{Right_Z} &amp; \color{PaleGreen}{Forward_Z} &amp; \color{LightSkyBlue}{Up_Z} &amp; \color{Khaki}{Translation_Z} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<h3 id="calculating-the-view-matrix">Calculating The View Matrix</h3>
<p>A view matrix needs translation (the position of the camera), and rotation (the view direction of the camera). It does the inverse of the model matrix. The model matrix takes points or vectors from the model’s local space, rotates them and then translates them, ending in global space. The camera matrix takes points or vectors from global space, translates them and then rotates them, ending with a point or vector in the camera’s local space. You could just calculate the model matrix for the camera, and then calculate the inverse matrix <a href="https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html">using maths</a>, but I’m trying to keep this as intuitive as possible.</p>
<p>The translation is simple, just negate the position of the camera. For example, if the camera is shifted along the positive X-axis by 5 units, from the point of view of the camera, this looks like everything in the world is shifted in 5 units along the negative X-axis.</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{1} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{-Translation_X} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{-Translation_Y} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{1} &amp; \color{Khaki}{-Translation_Z} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>For the rotation, you want to do the inverse of what the model rotation matrix would’ve done. A useful property of the rotation matrix (provided it is only rotating, and not reflecting/scaling/etc) is that it is <a href="https://en.wikipedia.org/wiki/Orthogonal_matrix">orthogonal</a>, this means the inverse is the same as the transpose matrix:</p>
<p>$$\begin{bmatrix}
\color{IndianRed}{Right_X} &amp; \color{PaleGreen}{Right_Y} &amp; \color{LightSkyBlue}{Right_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Forward_X} &amp; \color{PaleGreen}{Forward_Y} &amp; \color{LightSkyBlue}{Forward_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Up_X} &amp; \color{PaleGreen}{Up_Y} &amp; \color{LightSkyBlue}{Up_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}$$</p>
<p>What this matrix is doing is:</p>
<p>$$ Out_X = Right \cdot In $$
$$ Out_Y = Forward \cdot In $$
$$ Out_Z = Up \cdot In $$</p>
<p>This also makes intuitive sense when you picture it. Doing the dot product of the right axis with the input vector will measure the distance along the right axis where the input vector lies.</p>
<p>To combine the translation and rotation camera matrices, you reverse the order of the model matrix - again, picturing it in your head, you want to translate and then rotate:</p>
<p>$$ \begin{bmatrix}
\color{IndianRed}{Right_X} &amp; \color{PaleGreen}{Right_Y} &amp; \color{LightSkyBlue}{Right_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Forward_X} &amp; \color{PaleGreen}{Forward_Y} &amp; \color{LightSkyBlue}{Forward_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{Up_X} &amp; \color{PaleGreen}{Up_Y} &amp; \color{LightSkyBlue}{Up_Z} &amp; \color{Khaki}{0} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix}
\begin{bmatrix}
\color{IndianRed}{1} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{-Translation_X} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{1} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{-Translation_Y} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{1} &amp; \color{Khaki}{-Translation_Z} \\
\color{IndianRed}{0} &amp; \color{PaleGreen}{0} &amp; \color{LightSkyBlue}{0} &amp; \color{Khaki}{1}
\end{bmatrix} $$</p>
<p>However, you may not necessarily know the forward/up/right vectors of your camera, for example if you just want a camera at a certain position, which looks towards another position (usually called a look-at matrix).</p>
<p>The forward vector is the easiest part to find, simply find that by taking a vector from the camera position to the target position, and normalise it.</p>



    



    

<img src="/images/mpfps_07/diag18_hu3583fe31d262220d22899e7eeefa9445_47629_1000x0_resize_box_3.png"/>
<p>Finding the up vector is a bit more involved. Consider that we can use the forward vector to describe a plane.</p>



    



    

<img src="/images/mpfps_07/diag19_huf51e64637fa401413a3ba904acf3eea3_32828_1000x0_resize_box_3.png"/>
<p>The up, and right vectors will lie on this plane somewhere.</p>



    



    

<img src="/images/mpfps_07/diag20_hu0b8ad43f79395ea8038173bf0ff79075_40381_1000x0_resize_box_3.png"/>
<p>To find up, we first need some kind of idea of where &ldquo;up&rdquo; might be. So in this case we&rsquo;d just use the positive Z-axis. We then project that vector onto the plane, and normalise the result.</p>



    



    

<img src="/images/mpfps_07/diag21_hu82803b06c70a2051600964c71bd5e9ea_41230_1000x0_resize_box_3.png"/>
<p>Projecting a vector onto a plane is interesting. Given a plane P described by direction D, and projecting a vector V:</p>



    



    

<img src="/images/mpfps_07/diag22_hu7d1904c49e2908069a92ed131433ddfc_77863_1000x0_resize_box_3.png"/>
<p>So we can see that:</p>
<p>$$ V = V_{proj}D + V_{proj}P $$</p>
<p>Therefore:</p>
<p>$$ V_{proj}P = V - V_{proj}D $$</p>
<p>In this case, VprojP is the camera &ldquo;up&rdquo; vector, V is the world &ldquo;up&rdquo; vector, and D is the camera &ldquo;forward&rdquo; vector. So we project world &ldquo;up&rdquo; onto camera &ldquo;forward&rdquo;, subtract it from world &ldquo;up&rdquo;, normalise it, and we have the camera &ldquo;up&rdquo; vector. Armed with &ldquo;up&rdquo; and &ldquo;forward&rdquo;, the &ldquo;right&rdquo; vector can be computed with the cross product of the two.</p>
<h3 id="results">Results</h3>
<p>Putting everything together into a really wonky implementation, here’s the exact same movement code/data used for those awful 2D squares, but rendered in 3D:</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/peHf3l8F_q0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>


            
        </div>
    </article>

        </main>

        <footer class="footer">
    <div class="footer-left">
        <ul class="social">
            

            
                <li>Joe Best-Rotheray</li>
            

            
                
                    <li>
                        
                            <a href="mailto:joe@codersblock.org" target="_blank">
                                <i class="bi-envelope"></i>
                            </a>
                        

                    </li>
                
            
                
            
                
                    <li>
                        
                            <a href="spectre1989" target="_blank">
                                <i class="bi-github"></i>
                            </a>
                        

                    </li>
                
            
                
            
                
                    <li>
                        
                            <a href="joebestrotheray" target="_blank">
                                <i class="bi-linkedin"></i>
                            </a>
                        

                    </li>
                
            
                
            
                
            
                
                    <li>
                        
                            <a href="codersblock" target="_blank">
                                <i class="bi-twitter"></i>
                            </a>
                        

                    </li>
                
            
                
            
                
            
        </ul>
    </div>

    <div class="footer-right">
        <ul class="control status clearfix">
            
                <li>
                    
                        Word Count:
                        4072
                    
                </li>
            

            
            

            
                <li>en</li>
            

            
                <li>
                    <a href="https://gohugo.io" class="btn" target="_blank"
                        >Hugo: 0.121.2</a
                    >
                </li>
            

            
                <li>
                    <a
                        href="https://github.com/JingWangTW/dark-theme-editor"
                        class="btn"
                        target="_blank"
                        >Theme: dark-theme-editor</a
                    >
                </li>
            

            
                <li>
                    
                        Last modified: &nbsp;
                        <time>
                            May 29 2019 00:00:00
                        </time>
                    
                </li>
            

            
                <li title="">
                    
                </li>
            
        </ul>
    </div>
</footer>

    </body>

    























    
    


    
    


    <script
        type="text/javascript"
        src="/js/index_d751713.min.5eeb120f16ea146352725c420364f87befead45f678142b8f0ffbef024646931fbc06bff07a7bd6cb57fa2f8cd8a21ba6a4ee5a278ec32303a378bc1cd17f246.js"
        integrity="sha512-XusSDxbqFGNSclxCA2T4e&#43;/q1F9ngUK48P&#43;&#43;8CRkaTH7wGv/B6e9bLV/ovjNiiG6ak7lonjsMjA6N4vBzRfyRg=="></script>














<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" />




</html>
